[
  {
    "objectID": "mdst_graphs.html",
    "href": "mdst_graphs.html",
    "title": "Grafos e relações semânticas na linguagem natural",
    "section": "",
    "text": "Visão geral das relações entre os termos do Multilingual Data Stewardship Terminology"
  },
  {
    "objectID": "mdst_graphs.html#introdução",
    "href": "mdst_graphs.html#introdução",
    "title": "Grafos e relações semânticas na linguagem natural",
    "section": "Introdução",
    "text": "Introdução\nO universo do desenvolvimento de software é saturado de termos carregados de importância mas com vidas muito curtas, ou onde é difícil enxergar a diferença entre relevância e ruído. Isso impacta decisões — pessoais ou institucionais — sobre onde investir recursos ao aprender, pesquisar e ensinar tecnologias.\nComo conseguir analisar e representar visualmente a relevância de elementos de uma amostra que muda tão rapidamente? E será que ela muda tão rapidamente? Onde é a superfície e onde está o espaço mais profundo desses campos semânticos?\nSem intenção de dar uma resposta definitiva mas com interesse em explorar ferramentas, optei por uma perspectiva iterativa e que pudesse ser facilmente documentada e reproduzida.\nPara isso, escolhi como ferramenta principal a linguagem R e o sistema de publicação Quarto. Dessa maneira, foi possível usar um só ambiente para fazer a importação, limpeza, análise, visualização e ainda a exportação desse processo para uma página web apresentável.\nO dataset utilizado foi o SSHOC Multilingual Data Stewardship Terminology, um conjunto de definições ligadas à ideia de Data Stewardship, que pode ser traduzida como gestão ou administração de dados.\nO conjunto é resultado do trabalho de Francesca Frontini, Federica Gamba, Monica Monachini e Daan Broeder do Instituto de Linguística Computacional A. Zampolli, pelo Conselho Nacional de Pesquisa da Itália e traz 211 termos nos idiomas inglês, holandês, francês, alemão, italiano, grego e esloveno.\nEntre os termos mais relevantes, segundo as métricas desenvolvidas, destacaram-se (em tradução livre) metadado, conjunto de dados, dados de pesquisa, sujeito de dados, dados pessoais e dados brutos. Continue lendo se deseja saber mais sobre os resultados do estudo.\n\nAtalho\nAbaixo você encontra um relatório técnico detalhado, com todo o código executado para processar e analisar o conjunto de dados.\nSe prefere ler somente as conclusões resumidas e acionáveis, salte para o final. Se quiser ver apenas as visualizações mais relevantes, pode começar pela categorização ou ir diretamente para a seção 5."
  },
  {
    "objectID": "mdst_graphs.html#perguntar",
    "href": "mdst_graphs.html#perguntar",
    "title": "Grafos e relações semânticas na linguagem natural",
    "section": "1. Perguntar",
    "text": "1. Perguntar\n\nResumoAmostra da pesquisa\n\n\n\n\n\nObjetivo\nRepresentar visualmente as relações entre diferentes termos técnicos da área de dados\n\n\nProblema\nDeterminar quais termos são mais relevantes\n\n\nMétricas\nMenções de cada termo por um termo diferente do dataset\n\n\nPúblico\nProfissionais de PLN, pessoas treinadoras, produtoras de materiais e estudantes da área de dados\n\n\nDados\nSSHOC Multilingual Data Stewardship Terminology\n\n\n\nConjunto de dados utilizado:\n\nFrontini, Francesca; Gamba, Federica; Monachini, Monica and Broeder, Daan, 2021, SSHOC Multilingual Data Stewardship Terminology, ILC-CNR for CLARIN-IT repository hosted at Institute for Computational Linguistics “A. Zampolli”, National Research Council, in Pisa, http://hdl.handle.net/20.500.11752/ILC-567.\n\n\n\n\nResumo de resultados\n\n\n\nDataset\nObservações\n\n\n\n\nCLSE\nTermos genéricos demais\n\n\nRe-TACRED\nDados de treinamento para ML\n\n\nDVN_SHL1SL\nDados relacionais para semantic web\n\n\nUC11294871\nNão é um dataset\n\n\nCrowdTruth\nEstrutura confusa\n\n\nGraphine\nDados médicos\n\n\nSSHOC MDST\nTermos e definições de Data Stewardship\n\n\n\n\n\nFontes de busca\n\ndata.world\nstatista\naws opendata\nkaggle\ndata.gov\ndatahub.io\narchive.ics.uci.edu\ngoogle datasetsearch\n\nSSHOC Multilingual Data Stewardship Terminology\nGraphine: A Dataset for Graph-aware Terminology Definition Generation | Zenodo\nCrowdTruth Corpus for Open Domain Relation Extraction from Sentences | Zenodo\nUniversity of Southern California - Learning semantic types and relations from text\nAn Annotated Corpus of Webtables for Information Extraction Tasks - UAlberta Research Data Collection\n[2104.08398] Re-TACRED: Addressing Shortcomings of the TACRED Dataset\n\nresearch.google\n\nCLSE: Corpus of Linguistically Significant Entities – Google Research\n\ngoogle-research-datasets/clse - GitHub\n\n\n\n\n\n\n\nPara quantificar a relevância de um termo em relação aos demais, foi usada uma métrica aqui chamada de popularidade.\nO grafo é uma rede de elementos (chamados também nós ou nodes) que estão conectados por ligações (chamadas também de links ou edges).\n\n\n\nExemplo de um grafo simples.\n\n\nNo exemplo de grafo acima, o nó data structure recebe três ligações e tem portanto um valor de popularidade 3. O nó data object, por sua vez, recebe apenas duas ligações e tem popularidade 2.\nTrata-se da quantidade de vezes que um determinado nó (cada elemento da rede de conexões) recebe uma conexão. Para esse estudo, uma conexão representa uma menção daquele termo na definição de outro.\nPor exemplo, vemos abaixo a definição de data security:\n\n“Result of the data protection measures taken to guarantee data integrity.”\n\nAo mencionar tanto data protection quanto data integrity, as relações são estabelecidas através do mapeamento feito usando as ferramentas da linguagem R.\nPara esse estudo, não foram considerados termos no plural nem suas diferentes formas decompostas, apenas as junções exatas do termo. Contudo, foram levadas em conta todos os termos alternativos do conjunto de dados, na forma das AltLabels.\nIsso significa que um termo pode ter mais de um nome, como por exemplo ocorre com o termo data publication. Ele tem as AltLabels data publishing e publication of data. Qualquer uma delas, se mencionada na definição de outro termo, estabelece uma relação.\nPara grifar essa diferença, ao longo do estudo foram utilizadas diferentes cores ou formatos de linha para representar as diferentes relações entre cada termo."
  },
  {
    "objectID": "mdst_graphs.html#preparar",
    "href": "mdst_graphs.html#preparar",
    "title": "Grafos e relações semânticas na linguagem natural",
    "section": "2. Preparar",
    "text": "2. Preparar\nNesta etapa, os dados são carregados e preparados para o processamento.\nO arquivo de dados original é disponibilizado no formato csv e tem uma estrutura de dados longa. Isso significa que um mesmo ID se repete em diferentes linhas. Será preciso converter essa estrutura para uma forma ampla para que os dados possam ser manipulados e plotados.\nA preparação envolve ainda observar a confiabilidade dos dados. No conjunto original é possível ver que há múltiplas fontes possíveis para os dados. Na demo oficial do projeto também é possível ver o cruzamento das informações em um formato mais legível.\nOs dados não possuem dados pessoais para serem anonimizados e usa a licença pública Creative Commons - Attribution 4.0 International (CC BY 4.0).\n\nCarregamento\nPara começar a trabalhar de fato com os dados, começamos carregando as bibliotecas que serão usadas na etapa de limpeza:\n\nlibrary(tidyverse)\n\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──\n✔ ggplot2 3.4.0      ✔ purrr   0.3.5 \n✔ tibble  3.1.8      ✔ dplyr   1.0.10\n✔ tidyr   1.2.1      ✔ stringr 1.5.0 \n✔ readr   2.1.3      ✔ forcats 0.5.2 \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n\nlibrary(janitor)\n\n\nAttaching package: 'janitor'\n\nThe following objects are masked from 'package:stats':\n\n    chisq.test, fisher.test\n\n\nUsaremos a sigla MDST para nos referimos ao dataset. Ela representa o seu nome completo, Multilingual Data Stewardship Terminology.\n\nmdst <- read_delim(\"data/SSHOC/terminology.csv\", delim=\";\")\n\nNew names:\nRows: 490 Columns: 17\n── Column specification\n──────────────────────────────────────────────────────── Delimiter: \";\" chr\n(17): ...1, ...2, ...3, ...4, Translations, ...6, ...7, ...8, ...9, ...1...\nℹ Use `spec()` to retrieve the full column specification for this data. ℹ\nSpecify the column types or set `show_col_types = FALSE` to quiet this message.\n• `` -> `...1`\n• `` -> `...2`\n• `` -> `...3`\n• `` -> `...4`\n• `` -> `...6`\n• `` -> `...7`\n• `` -> `...8`\n• `` -> `...9`\n• `` -> `...10`\n• `` -> `...12`\n• `` -> `...13`\n• `` -> `...14`\n• `` -> `...15`\n• `` -> `...16`\n• `` -> `...17`\n\n\nPela saída da importação podemos ver que os nomes originais das colunas, por estarem distribuídos em duas linhas, não podem ser lidos automaticamente.\nAntes de prosseguir podemos verificar por problemas na importação:\n\nproblems(mdst)\n\n\n\n  \n\n\n\nE verificar os tipos de dados:\n\nspec(mdst)\n\ncols(\n  ...1 = col_character(),\n  ...2 = col_character(),\n  ...3 = col_character(),\n  ...4 = col_character(),\n  Translations = col_character(),\n  ...6 = col_character(),\n  ...7 = col_character(),\n  ...8 = col_character(),\n  ...9 = col_character(),\n  ...10 = col_character(),\n  Linking = col_character(),\n  ...12 = col_character(),\n  ...13 = col_character(),\n  ...14 = col_character(),\n  ...15 = col_character(),\n  ...16 = col_character(),\n  ...17 = col_character()\n)\n\n\nTodas as variáveis são do tipo character.\nVamos converter para um dataframe:\n\nmdst = data.frame(mdst)\n\nE agora temos o conjunto carregado:\n\nmdst %>% \n  filter(\n    grepl(\"data stewardship\", ...3, ignore.case = TRUE)\n  )\n\n\n\n  \n\n\n\nAcima, vemos uma busca pela definição do conceito de “data stewardship”.\n\nData stewardship can be defined as the tasks and responsibilities that relate to the management, sharing, and preservation of research data throughout the research lifecycle and beyond.\n\nEm tradução livre:\n\nGestão de dados pode ser definida como o conjunto de tarefas e responsabilidades que se relacionam à gestão, compartilhamento, e preservação de dados de pesquisa ao longo do ciclo de pesquisa e além dele."
  },
  {
    "objectID": "mdst_graphs.html#processar",
    "href": "mdst_graphs.html#processar",
    "title": "Grafos e relações semânticas na linguagem natural",
    "section": "3. Processar",
    "text": "3. Processar\nCom os dados carregados, podemos dar início à limpeza.\nTentando usar o conhecimento obtido ao longo da certificação, optei por utilizar apenas a linguagem R para fazer todo o processo.\nAlém da limpeza, serão realizados aqui alguns processos de validação para verificar se os dados realmente estão limpos e se não há informações duplicadas ou IDs faltando, já que na etapa de análise será necessário criar métricas que dependem de uma sequência precisa e ininterrupta de IDs.\n\nLimpeza\n\nCabeçalhos\nOs cabeçalhos das colunas vieram em duas colunas separadas, sendo portanto importados incorretamente por padrão.\n\ncolnames(mdst)\n\n [1] \"...1\"         \"...2\"         \"...3\"         \"...4\"         \"Translations\"\n [6] \"...6\"         \"...7\"         \"...8\"         \"...9\"         \"...10\"       \n[11] \"Linking\"      \"...12\"        \"...13\"        \"...14\"        \"...15\"       \n[16] \"...16\"        \"...17\"       \n\n\nVamos renomear as colunas usando a função clean_names do pacote janitor:\n\nmdst_cl <- mdst %>%\n  row_to_names(row_number = 1) %>% \n  clean_names() %>% \n  rename(type = na, source = source_of_definition)\n\nDuas colunas precisaram ainda ser nomeadas manualmente.\nAgora temos essas colunas:\n\ncolnames(mdst_cl)\n\n [1] \"concept_id\"                     \"type\"                          \n [3] \"term\"                           \"source\"                        \n [5] \"dutch\"                          \"french\"                        \n [7] \"german\"                         \"greek\"                         \n [9] \"italian\"                        \"slovenian\"                     \n[11] \"loterre_open_science_thesaurus\" \"terms4fair_skills\"             \n[13] \"ccr_metadata\"                   \"linked_open_vocabularies\"      \n[15] \"lov_2\"                          \"iso\"                           \n[17] \"broader_concept\"               \n\n\n\n\nPadronização\nExistem valores “AltLabel” e “altLabel” que poderiam ser padronizados para AltLabel:\n\nunique(mdst_cl$type)\n\n[1] \"PrefLabel\"  \"Definition\" \"AltLabel\"   \"altLabel\"  \n\n\nPara substituir como “AltLabel”:\n\nmdst_cl$type <- str_replace(mdst_cl$type, \"altLabel\", \"AltLabel\")\n\nE podemos verificar se a quantidade de “altLabel” agora é zero:\n\nmdst_cl %>% \n  filter(type == \"altLabel\") %>% \n  nrow() == 0 # TRUE\n\n[1] TRUE\n\n\nVamos testar se não houve erros na substituição somando os valores únicos:\n\nlocal({\n  lbls <- c(\"AltLabel\" = 0, \"altLabel \" = 0,\n            \"Definition\" = 0, \"PrefLabel\" = 0)\n  \n  for (i in 1:4) {\n    lbls[i] <- lbls[i] + mdst_cl %>% \n      filter(type == names(lbls)[i]) %>% \n      nrow()\n  }\n  \n  lbls; sum(lbls) == nrow(mdst_cl) # TRUE\n})\n\n[1] TRUE\n\n\nO código acima soma a quantidade de ocorrências de cada uma das quatro palavras. Um resultado TRUE significa que o total é igual ao total de linhas no dataframe (atualmente, 489).\nPodemos agora separar as colunas usando apenas ID, tipo e descrição para a análise.\n\nmdst_fl <- mdst_cl %>% \n  select(concept_id, type, term)\n\nPor fim, vamos converter todas as colunas para letras minúsculas, exceto a coluna type:\n\nmdst_fl <- mdst_fl %>%\n  mutate(concept_id = tolower(concept_id)) %>% \n  mutate(term = tolower(term))\n\n\n\nPivoting\nA seguir é preciso converter do formato longo para amplo.\nOs dados estão estruturados da seguinte forma:\n\n\n\nconcept_id\ntype\nterm\n\n\n\n\nA\nPrefLabel\nPrefLabel_A\n\n\nNA\nDefinition\nDefinition_A\n\n\nB\nPrefLabel\nPrefLabel_B\n\n\nNA\nDefinition\nDefinition_B\n\n\n\nOu seja, cada ID pode ter informações em mais de uma linha, que são definididas pela coluna “type”.\nHá ainda casos com três tipos, que incluem uma ou várias AltLabels:\n\n\n\nconcept_id\ntype\nterm\n\n\n\n\nB\nPrefLabel\nPrefLabel_B\n\n\nNA\nDefinition\nDefinition_B\n\n\nC\nPrefLabel\nPrefLabel_C\n\n\nNA\nAltLabel\nAltLabel_C\n\n\nNA\nDefinition\nDefinition_C\n\n\n\nPara fazer a conversão em um formato amplo, primeiro vamos preencher os valores NA da coluna concept_id com o último valor acima de cada NA:\n\nmdst_fl <- mdst_fl %>%\n  fill(names(mdst_fl), .direction = \"down\")\n\nAgora temos ainda o formato longo, mas os valores nulos (NA) foram preenchidos com os respectivos IDs:\n\nhead(mdst_fl, 10)\n\n\n\n  \n\n\n\nNão resta nenhum valor NA:\n\ncolSums(is.na(mdst_fl))\n\nconcept_id       type       term \n         0          0          0 \n\n\nAgora temos uma estrutura assim:\n\n\n\nconcept_id\ntype\nterm\n\n\n\n\nB\nPrefLabel\nPrefLabel_B\n\n\nB\nDefinition\nDefinition_B\n\n\nC\nPrefLabel\nPrefLabel_C\n\n\nC\nAltLabel\nAltLabel_C\n\n\nC\nDefinition\nDefinition_C\n\n\n\nO próximo passo é separar os tipos PrefLabel, Definition e AltLabel em suas próprias colunas.\nPodemos fazer isso com a função pivot_wider:\n\nmdst_pv <- mdst_fl %>% \n  pivot_wider(names_from = type, values_from = term, values_fn = list) %>% \n  mutate(PrefLabel = as.character(PrefLabel)) %>% \n  unnest_wider(AltLabel, names_sep = \"_\")\n\nPara que o pivoting com pivot_wider() una as linhas com conteúdos diferentes mas categorias iguais (na coluna type) usa-se a instrução unnest(), que separa essas linhas novamente. Do contrário, haveria a perda de dados.\nEste post no rdrr.io foi essencial para compreender melhor a solução.\nO seguinte erro era gerado sem ela:\nWarning: Values from `term` are not uniquely identified; output will contain list-cols.\n* Use `values_fn = list` to suppress this warning.\n* Use `values_fn = {summary_fun}` to summarise duplicates.\n* Use the following dplyr code to identify duplicates.\n  {data} %>%\n    dplyr::group_by(concept_id, type) %>%\n    dplyr::summarise(n = dplyr::n(), .groups = \"drop\") %>%\n    dplyr::filter(n > 1L)\nO que isso indica é que valores de coluna duplicados são, por padrão, unidos em listas para que não sejam perdidos na hora de juntar as linhas por seus IDs.\nAgora vamos converter de volta para um dataframe:\n\nmdst_pv <- data.frame(mdst_pv)\n\nE finalmente temos um único concept_id por observação:\n\nlength(unique(mdst_pv$concept_id))== mdst_fl %>% select(concept_id) %>% unique() %>% nrow()\n\n[1] TRUE\n\n\nPara ficar mais fácil de entender a tabela, vamos reordenar as colunas:\n\nmdst_pv <- mdst_pv %>% \n  select(concept_id, PrefLabel, Definition, AltLabel_1, AltLabel_2, AltLabel_3)\n\n\n\nDeduplicação\nAgora que a maioria das partes duplicadas foi removida, é possível focar no restante. Vamos ver quantos itens únicos temos na coluna Definition:\n\nlength(unique(mdst_pv$Definition))\n\n[1] 209\n\n\n209 é muito mais próximo do número de definições mostrado nos metadados, 211.\nA quantidade de IDs únicos é 209:\n\nlength(unique(mdst_pv$concept_id))\n\n[1] 209\n\n\nEsse valor é o mesmo antes e depois da mudança para uma estrutura ampla:\n\nlength(unique(mdst_pv$concept_id)) == length(unique(mdst_fl$concept_id))\n\n[1] TRUE\n\n\nAgora vamos contar os valores únicos de cada coluna:\n\nmdst_pv %>%\n  summarize_all(n_distinct) %>% \n  mutate(AltLabel_total = sum(AltLabel_1, AltLabel_2, AltLabel_3))\n\n\n\n  \n\n\n\nNos metadados do conjunto há a informação de que são 210 conceitos. A página online informa 211 conceitos.\nAbaixo foi feito um cruzamento dos dados em seu estado atual com os totais exibidos na página do SSHOC:\n\n\n\nColuna\nOriginal\nAtual\nDiferença\n\n\n\n\nconcept_id\n211\n209\n2\n\n\nPrefLabel\n211\n209\n2\n\n\nDefinition\n211\n209\n2\n\n\nAltLabel\n61\n73\n-12\n\n\n\nNo nosso data frame atual temos 209 IDs, 209 PrefLabel e 209 definições, todos valores únicos. Faltam dois itens para cada.\nO maior problema ainda são as AltLabels. Temos 70 AltLabels, o que significa que temos 12 AltLabels a mais. O que encontramos até agora removeria apenas duas AltLabels, deixando ainda outras 7. É possível que haja mais duplicações entre as colunas que foram separadas.\nSe olharmos o último ID, ele é “version_control_211”:\n\ntail(mdst_fl, 1)\n\n\n\n  \n\n\n\nObservando os dados para tentar entender a diferença entre os 211 IDs e as 209 observações, percebi que o número das linhas não batia com o dos IDs.\nPor exemplo, os IDs 170 e 171 são pulados:\n\nmdst_pv[168:173, ]\n\n\n\n  \n\n\n\nOlhando no conjunto original, eles também não constam:\n\nmdst %>% \n  mutate(row = row_number()) %>% \n  filter(...1 == \"orphan_data_169\") %>% \n  select(...1, row)\n\n\n\n  \n\n\n\n\nmdst[396:410, ]\n\n\n\n  \n\n\n\nParece não existir uma PrefLabel nem um concept_id para a AltLabel “PID”.\nEscrevi primeiro um teste que encontra as linhas que não batem com os seus IDs:\nPara isso criei uma nova coluna com apenas o número do ID:\n\nmdst_pv <- mdst_pv %>% \n  mutate(id_no = str_replace(concept_id, \"^.*_\", \"\")) %>% \n  mutate(id_no = as.integer(id_no))\n\nE usei o somatório de 1 a 211 junto com um loop for para verificar se os números estão em sequência e não são duplicados. Isso também facilita encontrar exatamente onde está o erro:\n\nfor (i in 1:211) {\n  if (i != mdst_pv$id_no[i]) {\n    print(\n      paste(i, \"!=\", mdst_pv$id_no[i])\n      )\n    break\n  }\n}\n\n[1] \"170 != 172\"\n\nrm(i); paste(\"Diferença:\", sum(1:211) - sum(mdst_pv$id_no))\n\n[1] \"Diferença: 341\"\n\n\nIsso nos leva de novo à linha 170:\n\nmdst_pv[168:172,]\n\n\n\n  \n\n\n\nAqui parece ter faltado um concept_id para a entrada referente a “PID” e há ainda uma entrada faltando após essa, que seria do ID 171. Isso teve algumas consequências:\n\nO campo Definition do ID orphan_data_169 ficou com sua própria definição e a de PID juntas\n“PID” ficou como a AltLabel do ID orphan_data_169.\n\n\n\nInserção\nPara alterar os dados da coluna Definition — atualmente do tipo lista devido a essa entrada duplicada — será preciso tipá-la como character:\n\nmdst_pv <- mdst_pv %>% \n  mutate(Definition = as.character(Definition))\n\nE agora vamos adicionar o ID personal_identifier_170 para essa observação e as informações do ID 171 encontradas na página web do projeto:\n\nmdst_ad <- mdst_pv %>% \n  add_row(tibble_row(\n    concept_id = \"persistent_identification_170\", PrefLabel = \"persistent identification\", Definition = \"the act of identifying a resource via its persistent identifier.\", id_no = as.integer(170)), .after = 169) %>% \n  add_row(tibble_row(\n    concept_id = \"persistent_identifier_171\", PrefLabel = \"persistent identifier\", Definition = \"a unique and stable denomination (reference) of a digital resource (e.g. research data) through allocation of a code that can be persistently and explicitly referenced on the internet.\", AltLabel_1 = \"pid\", id_no = as.integer(171)), .after = 170) %>% \n  mutate(id_no = as.integer(id_no))\n\nConferindo se está tudo certo:\n\nmdst_ad[170:171,]\n\n\n\n  \n\n\n\nAgora precisamos retirar a AltLabel e definição extras em orphan_data_169:\n\nmdst_ad[169,] <- tibble_row(concept_id = \"orphan_data_169\", PrefLabel = \"orphan data\", Definition = \"data that is not machine readable because the data exists with no identifiable computer application or system that can retrieve it, or the data is machine readable but does not have sufficient content, context or structure to render it understandable.\", AltLabel_1 = NA, AltLabel_2 = NA, AltLabel_3 = NA, id_no = as.integer(169))\n\nVamos ver como ficou essa área novamente:\n\nmdst_ad[168:172,]\n\n\n\n  \n\n\n\n\n\nValidação\nFeitas essas inserções e transformações, podemos executar o teste criado anteriormente para validar que a sequência de IDs agora está correta.\nPrimeiro vamos reescrever a coluna id_no com os números da coluna concept_id, já que ela foi alterada:\n\nmdst_ad <- mdst_ad  %>% \n  mutate(id_no = str_replace(concept_id, \"^.*_\", \"\")) %>% \n  mutate(id_no = as.integer(id_no))\n\nE então executar o teste:\n\nfor (i in 1:211) {\n  if (i != mdst_ad$id_no[i]) {\n    print(\n      paste(\"Erro no índice\", i, \"id_no:\", mdst_ad$id_no[i], \"ID:\", mdst_ad$concept_id)\n      )\n    break\n  }    \n}\n\nrm(i); paste(\"Diferença:\", sum(1:211) - sum(mdst_ad$id_no)) # 0\n\n[1] \"Diferença: 0\"\n\n\nCom os números dos IDs agora iguais aos números de cada observação, podemos remover a coluna id_no:\n\nmdst_ad <- select(mdst_ad, !id_no)\n\n\n\nMais deduplicação\nAntes de fazer mais validações, vamos remover qualquer caractere de espaço que esteja sobrando ou duplicado:\n\nmdst_adt <- mdst_ad %>% \n  mutate_if(is.character, trimws) %>% \n  mutate_if(is.character, gsub, pattern = \"  \", replacement = \" \")\n\nIsso parece ter provocado nove alterações no dataframe:\n\ntable(mdst_adt == mdst_ad)\n\n\nFALSE  TRUE \n    9   694 \n\n\nPodemos encontrar em qual coluna elas estão com sapply():\n\nas_tibble(mdst_adt == mdst_ad) %>% \n  sapply(table)\n\n$concept_id\n\nTRUE \n 211 \n\n$PrefLabel\n\nTRUE \n 211 \n\n$Definition\n\nFALSE  TRUE \n    9   202 \n\n$AltLabel_1\n\nTRUE \n  57 \n\n$AltLabel_2\n\nTRUE \n  12 \n\n$AltLabel_3\n\nTRUE \n   1 \n\n\nSabendo que todos se encontram na coluna Definition, vamos encontrar quais foram elas usando a função setdiff():\n\nsetdiff(mdst_adt$Definition, mdst_ad$Definition)\n\n[1] \"formal document that outlines how to handle research data both during your research and after the research project is completed.\"                                                                        \n[2] \"data modeling is the process of creating a visual representation of either a whole information system or parts of it to communicate connections between data points and structures.\"                     \n[3] \"the practice of making data available for reuse. this may be done, for example, by depositing the data in a repository, through data publication.\"                                                       \n[4] \"data stewardship can be defined as the tasks and responsibilities that relate to the management, sharing, and preservation of research data throughout the research lifecycle and beyond.\"               \n[5] \"data storage is the recording (storing) of information (data) in a storage medium.\"                                                                                                                      \n[6] \"hierarchical data is defined as a set of data items that are related to each other by hierarchical relationships. hierarchical relationships exist where one item of data is the parent of another item.\"\n[7] \"online, free of cost, accessible data that can be used, reused and distributed provided that the data source is attributed.\"                                                                             \n[8] \"the practice of making research data available for reuse. this may be done, for example, by depositing the research data in a repository, through research data publication.\"                            \n\n\nA função retornou apenas oito resultados. Vamos inspecionar mais de perto o resultado anterior achando qual é o concept_id de cada uma das nove linhas encontradas:\n\nmdst_adt_diff <- mdst_ad\n\nmdst_adt_diff$Definition <- (mdst_adt$Definition == mdst_ad$Definition)\n\nmdst_adt_diff %>% \n  filter(Definition == FALSE) %>% \n  select(concept_id, Definition)\n\n\n\n  \n\n\n\nVemos aqui que o ID metadata_158 é o único a não ser encontrado na comparação com setdiff(mdst_adt$Definition, mdst_ad$Definition).\nPodemos confirmar isso retirando o texto sem espaços extras do texto original e vendo se resta apenas um espaço.\nO código a seguir usa a função mutate_all para criar uma tabela que mostra todas as colunas comparadas.\n\nmdst_adc <- mdst_ad %>% \n  mutate_all(list(~ str_trim(., side = \"both\"),\n                  ~ str_replace_all(., \"  \", \" \")))\n\nA função mutate_all acima recebe uma lista de funções anônimas como argumento. O símbolo de fórmulas ~ faz com que o código fique mais limpo, evitando ter de declarar as funções como function .... Os pontos servem para capturar os argumentos passados pela mutate_all para cada observação do conjunto.\nO resultado será um novo dataframe com novas colunas com o nome da função aplicada no final. Teremos portanto uma coluna “concept_id” com os dados originais, outra com “concept_id_str_trim”, e outra com “concept_id_replace_all” e assim por diante para todas as colunas.\nEsse é nosso conjunto comparando todas as diferenças:\n\nmdst_adc\n\n\n\n  \n\n\n\nCom base nesse conjunto, podemos tentar chegar às diferenças exatas entre as strings originais e suas versões limpas:\n\ndiff_final <- mdst_adc %>% \n  mutate(trim_diff = str_replace(Definition, fixed(Definition_str_trim), \"\")) %>% \n  mutate(replace_diff = str_replace(Definition, fixed(Definition_str_replace_all), \"\")) %>% \n  mutate(bools_diff = mdst_adt_diff$Definition) %>% \n  filter(bools_diff == FALSE) %>% \n  select(concept_id, trim_diff, replace_diff)\n\nAtravés desse resultado podemos saber que cada linha diferente possuía um espaço em branco:\n\ndiff_final %>% \n  filter(trim_diff == \" \")\n\n\n\n  \n\n\n\nE que não havia espaços duplicados:\n\ndiff_final %>% \n  filter(replace_diff == \"\")\n\n\n\n  \n\n\n\n\n\n\nVamos verificar se há mais itens duplicados agora que retiramos espaços em excesso e desagregamos as listas:\n\nmdst_adt %>%\n  summarize_all(n_distinct) %>% \n  mutate(AltLabel_total = sum(AltLabel_1, AltLabel_2, AltLabel_3))\n\n\n\n  \n\n\n\nOs valores das AltLabels não se alteraram desde a primeira verificação. Os IDs ainda são únicos. Mas parece que ainda há uma definição duplicada.\nVamos encontrá-la criando um teste para achar valores duplicados:\n\ndup_check <- function(df, col) {\n  df %>% \n  select(all_of(col)) %>% \n  drop_na() %>% \n  duplicated() %>% \n  as_tibble() %>% \n  mutate(row_no = row_number()) %>% \n  filter(value == TRUE)\n}\n\nEssa função recebe um dataframe e uma coluna e cria um dataframe booleano com TRUE para duplicatas. Ela adiciona uma coluna com o número da linha correspondente e um filtro para retornar apenas os valores duplicados.\nVamos executar o teste na coluna Definition:\n\ndup_check(mdst_adt, \"Definition\")\n\n\n\n  \n\n\n\nEla indica que a linha 171 tem um erro de duplicação. Já trabalhamos nessa linha ao resolver a falta de informações. Essa descrição foi inserida manualmente nessa etapa, e está correta de acordo com o ID persistent_identifier_171.\nVamos então procurar qual é a sua duplicata:\n\nmdst_adt %>% \n  filter(Definition == mdst_adt[171,]$Definition)\n\n\n\n  \n\n\n\nO ID metadata_158 está com a descrição incorreta. Ela é uma duplicação da definição do ID persistent_identifier_171.\nVamos verificar onde esse ID está no conjunto original para encontrar a origem do erro:\n\nmdst %>% \n  mutate(row_no = row_number()) %>% \n  filter(...1 == \"metadata_158\") %>% \n  select(...1, row_no)\n\n\n\n  \n\n\n\nAcessando um recorte dessa linha, vemos que o erro já estava presente desde o dataset original.\n\nmdst[368:380,1:3]\n\n\n\n  \n\n\n\nAo contrário dos erros anteriores, na página oficial do projeto a informação também está duplicada. Usaremos como dados de proxy os de uma referência usada no próprio conjunto, a FRBR-aligned Bibliographic Ontology.\n\nmdst_adt[158,]$Definition <- \"a separate work that provides information describing one or more characteristics of a resource or entity.\"\n\nAgora sim temos 211 entradas únicas para todas as variáveis:\n\nmdst_adt %>%\n  summarize_all(n_distinct) %>% \n  mutate(AltLabel_total = sum(AltLabel_1, AltLabel_2, AltLabel_3))\n\n\n\n  \n\n\n\nQuanto a duplicações entre as diferentes colunas de AltLabels, testes sucessivos como o demonstrado abaixo foram usados para encontrá-las também:\n\nmdst_adt %>% \n  filter(AltLabel_1 == AltLabel_2) %>% \n  select(AltLabel_1, AltLabel_2) \n\n\n\n  \n\n\n\n\nmdst_adt %>% \n  filter(AltLabel_2 == AltLabel_3) %>% \n  select(AltLabel_2, AltLabel_3) \n\n\n\n  \n\n\n\n\nmdst_adt %>% \n  filter(AltLabel_1 == AltLabel_3) %>% \n  select(AltLabel_3, AltLabel_3)\n\n\n\n  \n\n\n\nFoi encontrada apenas uma duplicação das AltLabel_1 e AltLabel_2 “raw data”. Vamos encontrar a qual ID se referem:\n\nmdst_adt %>% \n  filter(AltLabel_1 == \"raw data\")\n\n\n\n  \n\n\n\nE portanto remover a AltLabel_2 da linha 181:\n\nmdst_adt[181,]$AltLabel_2 <- NA\n\nTotais de duplicações por coluna:\n\nlbls = c(\"concept_id\" = 0, \"AltLabel_1\" = 0, \"AltLabel_2\" = 0, \"AltLabel_3\" = 0)\n\nfor (i in 1:4) {\n  lbls[i] <- dup_check(mdst_adt, names(labels)[i]) %>% \n    nrow()\n}\n\nlbls; rm(lbls, i)\n\nconcept_id AltLabel_1 AltLabel_2 AltLabel_3 \n         0          0          0          0 \n\n\n\n\n\nModelagem\nAntes de mapear as relações, precisei entender qual era a estrutura que os dados deveriam usar.\nPara isso estudei os exemplos e a documentação da primeira biblioteca, a ggraph, que utiliza alguns princípios da ggplot — abordados na certificação — para fazer visualizações de grafos:\n\nthomasp85/ggraph: Grammar of Graph Graphics\nAn Implementation of Grammar of Graphics for Graphs and Networks • ggraph\n\n\nlibrary(ggplot2)\nlibrary(ggraph)\nlibrary(tidygraph)\n\n\nAttaching package: 'tidygraph'\n\n\nThe following object is masked from 'package:stats':\n\n    filter\n\n\nEsse é o exemplo mais simples encontrado de um conjunto de dados compatível com a ggraph:\n\nhighschool\n\n\n\n  \n\n\n\nA documentação mostra como obter uma medida de popularidade:\n\ngraph <- as_tbl_graph(highschool) %>% \n  mutate(Popularity = centrality_degree(mode = \"in\"))\n\nA estrutura fica dessa forma:\n\ngraph\n\n# A tbl_graph: 70 nodes and 506 edges\n#\n# A directed multigraph with 1 component\n#\n# Node Data: 70 × 2 (active)\n  name  Popularity\n  <chr>      <dbl>\n1 1              2\n2 2              0\n3 3              0\n4 4              4\n5 5              5\n6 6              2\n# … with 64 more rows\n#\n# Edge Data: 506 × 3\n   from    to  year\n  <int> <int> <dbl>\n1     1    13  1957\n2     1    14  1957\n3     1    20  1957\n# … with 503 more rows\n\n\nEssa é a visualização do conjunto acima:\n\nggraph(graph, layout = \"kk\") +\n  geom_edge_fan(aes(alpha = after_stat(index)), show.legend = FALSE)\n\n\n\n\nEla mostra apenas as ligações entre cada nó.\nNo exemplo abaixo, pontos são usados nos nós para representar a popularidade:\n\nggraph(graph, layout = \"kk\") +\n  geom_edge_fan(aes(alpha = after_stat(index)), show.legend = FALSE) +\n  geom_node_point(aes(size = Popularity))\n\n\n\n\nE aqui o grafo é separado em duas facetas de acordo com a variável year:\n\nggraph(graph, layout = \"kk\") +\n  geom_edge_fan(aes(alpha = after_stat(index)), show.legend = FALSE) +\n  geom_node_point(aes(size = Popularity)) +\n  facet_edges(~year) +\n  theme_graph(foreground = \"purple4\", fg_text_colour = \"white\")\n\n\n\n\n\nSobre cores em R: R colors [Full List, Color Converter and Color Picker] | R CHARTS\n\nComo é difícil entender esse exemplo com tanta informação, decidi filtrar as 10 primeiras linhas do conjunto highschool.\n\nrm(graph)\n\nhs10 <- highschool %>% \n  head(10)\n\nhs10_graph <- as_tbl_graph(hs10) %>% \n  mutate(Popularity = centrality_degree(mode = \"in\"))\n\nAgora temos as seguintes amostras:\nDez primeiras linhas do conjunto highschool:\n\nhs10\n\n\n\n  \n\n\n\nEstrutura:\n\nstr(hs10)\n\n'data.frame':   10 obs. of  3 variables:\n $ from: num  1 1 1 1 1 2 2 3 3 4\n $ to  : num  14 15 21 54 55 21 22 9 15 5\n $ year: num  1957 1957 1957 1957 1957 ...\n\n\nTodos os valores são numéricos.\nEsse é o grafo dessas dez primeiras linhas, exibido como uma árvore:\n\nhs10_graph\n\n# A tbl_graph: 12 nodes and 10 edges\n#\n# A rooted forest with 2 trees\n#\n# Node Data: 12 × 2 (active)\n  name  Popularity\n  <chr>      <dbl>\n1 1              0\n2 2              0\n3 3              0\n4 4              0\n5 14             1\n6 15             2\n# … with 6 more rows\n#\n# Edge Data: 10 × 3\n   from    to  year\n  <int> <int> <dbl>\n1     1     5  1957\n2     1     6  1957\n3     1     7  1957\n# … with 7 more rows\n\n\nEle tem essa estrutura:\n\nstr(hs10_graph)\n\nClasses 'tbl_graph', 'igraph'  hidden list of 10\n $ : num 12\n $ : logi TRUE\n $ : num [1:10] 0 0 0 0 0 1 1 2 2 3\n $ : num [1:10] 4 5 6 7 8 6 9 10 5 11\n $ : num [1:10] 0 1 2 3 4 5 6 8 7 9\n $ : num [1:10] 0 1 8 2 5 3 4 6 7 9\n $ : num [1:13] 0 5 7 9 10 10 10 10 10 10 ...\n $ : num [1:13] 0 0 0 0 0 1 3 5 6 7 ...\n $ :List of 4\n  ..$ : num [1:3] 1 0 1\n  ..$ : Named list()\n  ..$ :List of 2\n  .. ..$ name      : chr [1:12] \"1\" \"2\" \"3\" \"4\" ...\n  .. ..$ Popularity: Named num [1:12] 0 0 0 0 1 2 2 1 1 1 ...\n  .. .. ..- attr(*, \"names\")= chr [1:12] \"1\" \"2\" \"3\" \"4\" ...\n  ..$ :List of 1\n  .. ..$ year: num [1:10] 1957 1957 1957 1957 1957 ...\n $ :<environment: 0x5560d370a260> \n - attr(*, \"active\")= chr \"nodes\"\n\n\nSe plotarmos apenas essa amostra, temos o seguinte grafo:\n\nggraph(hs10_graph, layout = \"kk\") +\n  geom_edge_fan(aes(alpha = after_stat(index)), show.legend = TRUE) +\n  geom_node_point(aes(size = Popularity)) +\n  facet_edges(~year) +\n  theme_graph(foreground = \"purple4\", fg_text_colour = \"white\")\n\n\n\n\nAnalisando a coluna de popularidade, nesse ponto percebi que ela se refere à quantidade de vezes que um valor é mencionado na coluna “to”.\nSe ordenarmos os nós pela popularidade, temos 15 e 21 no topo:\n\nhs10_graph %>% \n  arrange(desc(Popularity))\n\n# A tbl_graph: 12 nodes and 10 edges\n#\n# A rooted forest with 2 trees\n#\n# Node Data: 12 × 2 (active)\n  name  Popularity\n  <chr>      <dbl>\n1 15             2\n2 21             2\n3 14             1\n4 54             1\n5 55             1\n6 22             1\n# … with 6 more rows\n#\n# Edge Data: 10 × 3\n   from    to  year\n  <int> <int> <dbl>\n1     9     3  1957\n2     9     1  1957\n3     9     2  1957\n# … with 7 more rows\n\n\nDo lado direito, sozinhos, o ponto maior é 5, que recebe uma conexão de 4, e o menor é 4, que não recebe nenhuma conexão.\nIsso também mostra que a parte transparente das linhas (edges) que conectam os nós é mais fraca na parte em que sai do nó. Isso é definido em geom_edge_fan(aes(alpha = after_stat(index))\nNa página sobre Edges encontrei como tornar as linhas em setas e nomear os nós:\n\nggraph(hs10_graph, layout = \"kk\") + \n  geom_edge_link(aes(start_cap = label_rect(node1.name),\n                     end_cap = label_rect(node2.name)), \n                 arrow = arrow(length = unit(4, \"mm\"))) + \n  geom_node_point(aes(size = Popularity), color = \"gray\") +\n  geom_node_text(aes(label = name))\n\n\n\n\nA visualização acima foi essencial para compreender a biblioteca através de um exemplo prático e reduzido, e confirmar as suspeitas descritas anteriormente.\nA documentação sobre nodes da biblioteca ggpraph tem muitos exemplos interessantes. Para não perder tempo, porém, decidi primeiro transformar os dados do projeto para que pudesse fazer mais testes já usando eles.\nAgora já temos uma ideia de que tipo de esquema precisamos para usar a estrutura de grafo. Ele parece ser centrado nas colunas “name” (um “ID”), “from” e “to” (de/para), que indicam as conexões de saída e entrada, e uma coluna de “popularidade” que mostra o total de menções daquele ID na coluna “para”.\n\n\nMapeamento\nPodemos começar limpando o ambiente. Vamos trabalhar com o conjunto “termos” como o resultado da limpeza feita até aqui.\n\ntermos <- mdst_adt\nrm(mdst_ad, mdst_adc, mdst_cl, mdst_fl, mdst_pv, dup_check, hs10_graph, hs10)\n\nPara podermos plotar um grafo e observar relações, será necessário então ter uma estrutura similar a essa:\n# A tibble: 6 × 2\n   from    to\n  <dbl> <dbl>\n1     1    14\n2     1    15\n3     1    21\n4     1    54\n5     1    55\n6     2    21\nMas para termos também a informação de que tipo de relação existe entre cada nó, seria preferível uma estrutura assim:\n\n\n\nfrom\nto\nedge\n\n\n\n\n1\n14\nPrefLabel\n\n\n2\n15\nAltLabel1\n\n\n3\n21\nAltLabel1\n\n\n4\n54\nPrefLabel\n\n\n5\n55\nAltLabel2\n\n\n6\n21\nPrefLabel\n\n\n7\n34\nPrefLabel\n\n\n8\n66\nPrefLabel\n\n\n9\n11\nAltLabel3\n\n\n10\n80\nPrefLabel\n\n\n\nA diferença entre PrefLabel e AltLabel é apenas uma possibilidade entre várias que podem ser usadas para determinar qual é a relação entre os dois termos. Neste caso, a diferença entre a AltLabel ser 1, 2 ou 3 é pouco relevante, então não será usada.\nOutras relações poderiam ser relacionadas à semântica presente na frase, por exemplo, se o termo é mencionado na definição como “é” ou “não é”, como um “tipo de” ou “pertence a”, etc.\nAqui vamos utilizar um algoritmo simples que apenas conta a quantidade de menções de cada PrefLabel ou AltLabel e as adiciona em uma tabela de relações:\n\n\n\n\nflowchart TB\n    a( ) -->\n    \n    A{id = pair} -- T --> B[pair = pair + 1]\n    B --> Ae( )\n    A -- F --> Ae( )\n    Ae( ) --> C{pair contém \\nPrefLabel}\n    C -- T --> D[adiciona a \\nrelacoes]\n    D --> Ce( )\n    C -- F --> E{pair contém \\nAltLabel}\n    E -- T --> F[adiciona a \\nrelacoes]\n    E -- F --> Ee( )\n    \n    F --> Ee( )\n    Ee --> Ce( )\n\n    --> z( )\n\n\n\n\n\n\n\n\nPor exemplo, o ID discovery_metadata_141 tem uma definição que começa com “Metadata that are used for the discovery of data”. Essa definição contém a PrefLabel “metadata” do ID metadata_158.\nIsso criará uma relação com origem (from) em discovery_metadata_141 e chegada (to) em metadata_158 com a relação (edge) PrefLabel:\n\n\n\nfrom\nto\nedge\n\n\n\n\n141\n157\nPrefLabel\n\n\n\nVamos criar o dataframe relacoes com uma coluna para a relação de origem (from), de chegada (to) e uma coluna para saber qual é o tipo de relação (edge), optando apenas entre PrefLabel e AltLabel.\n\nrelacoes = data.frame(to = 0, from = 0, edge = \"none\")\n\nstr(relacoes)\n\n'data.frame':   1 obs. of  3 variables:\n $ to  : num 0\n $ from: num 0\n $ edge: chr \"none\"\n\n\nO código abaixo implementa o algoritmo mostrado acima.\nEle percorre nosso conjunto de dados e mapeia cada relação em uma nova linha, gravando o ID de origem e destino de cada menção de um PrefLabel em uma Definition.\n\n\nCódigo\nmatches <- 1\nfor (id in 1:nrow(termos)) {\n  \n  \n  for (pair in 1:nrow(termos)) {\n    \n    if (id == pair) {\n      pair <- pair + 1\n    }\n    else {\n      if (str_detect(termos[pair,]$Definition, \n           paste0(\"\\\\b\", termos[id,]$PrefLabel, \"\\\\b\")) == TRUE) {\n        \n        relacoes[matches,] <- c(id, pair, \"PrefLabel\")\n        matches <- matches + 1\n      }\n      else if (is.na(termos[id,]$AltLabel_1) == FALSE &&\n               str_detect(termos[pair,]$Definition, \n                paste0(\"\\\\b\", termos[id,]$AltLabel_1, \"\\\\b\")) == TRUE) {\n        \n        relacoes[matches,] <- c(id, pair, \"AltLabel\")\n        matches <- matches + 1\n      }\n      else if (is.na(termos[id,]$AltLabel_2) == FALSE &&\n               str_detect(termos[pair,]$Definition,\n                paste0(\"\\\\b\", termos[id,]$AltLabel_2, \"\\\\b\")) == TRUE) {\n        relacoes[matches,] <- c(id, pair, \"AltLabel\")\n        matches <- matches + 1\n      }\n      else if (is.na(termos[id,]$AltLabel_3) == FALSE &&\n               str_detect(termos[pair,]$Definition,\n                paste0(\"\\\\b\", termos[id,]$AltLabel_3, \"\\\\b\")) == TRUE) {\n        relacoes[matches,] <- c(id, pair, \"AltLabel\")\n        matches <- matches + 1\n      }\n    }\n    \n  }\n}\n\npaste(\"Matches:\", matches)\n\n\n[1] \"Matches: 138\"\n\n\n\n\n\nPossivelmente existem soluções menos iterativas. Essa técnica não seria útil para um conjunto de dados muito grande.\nApós o mapeamento, foram encontradas um total de 138 relações.\nTerminada a manipulação como strings, vamos tipar os IDs como inteiros de novo:\n\nrelacoes <- relacoes %>% \n  mutate(across(c(1, 2), as.integer))\n\nEntre as relações, a maioria acontece por PrefLabels:\n\n\nCódigo\nrelacoes %>% \n  select(edge) %>% \n  ggplot(aes(x = edge, fill = edge)) +\n  geom_bar() +\n  geom_text(aes(label = after_stat(count)), stat = \"count\", vjust = 2, colour = \"white\") +\n  theme(legend.position = \"none\")\n\n\n\n\n\nApenas 24 relações são AltLabels.\nUma vez com as relações mapeadas, podemos começar a estruturar os dados para plotagem:\n\nlibrary(ggplot2)\nlibrary(ggraph)\nlibrary(tidygraph)\n\nPor fim é preciso criar um grafo com o tipo tbl_graph (do pacote tidygraph), que será passado às funções da biblioteca ggraph para gerar os grafos:\n\ngrafo <- as_tbl_graph(relacoes, nodes = termos, edges = relacoes) %>% \n  mutate(Popularity = centrality_degree(mode = \"in\")) %>% \n  mutate(Community = as.factor(group_infomap()))\n\nEste grafo já incluirá informações de popularidade e comunidade.\nAgora podemos começar a visualizar as relações entre os termos."
  },
  {
    "objectID": "mdst_graphs.html#analisar",
    "href": "mdst_graphs.html#analisar",
    "title": "Grafos e relações semânticas na linguagem natural",
    "section": "4. Analisar",
    "text": "4. Analisar\n\n\nCódigo\nggraph(grafo, layout = \"kk\") +\n  geom_edge_fan(aes(alpha = after_stat(index)), show.legend = TRUE) +\n  geom_node_point(aes(size = Popularity), color = \"black\") +\n  theme_graph(foreground = \"purple4\", fg_text_colour = \"white\")\n\n\n\n\n\nA primeira informação que logo vemos aqui é que há um aglomerado principal, do lado esquerdo, e apenas alguns aglomerados menores, unindo no máximo cinco termos.\nEntre estes conjuntos menores temos um com 5 elementos, 4 com 3 elementos e outros 5 com 2 elementos cada.\nAo tentar adicionar os nomes de cada nó, percebi que a quantidade de texto é enorme e fica pior ainda se adicionamos os nomes das conexões:\n\n\nCódigo\nggraph(grafo, layout = \"kk\") + \n  geom_edge_link(aes(),\n                 arrow = arrow(length = unit(4, \"mm\")),\n                 end_cap = circle(3, \"mm\")) +\n  geom_edge_link(aes(start_cap = label_rect(node1.name),\n                 end_cap = label_rect(node2.name)), \n                 arrow = arrow(length = unit(1, \"mm\"))) + \n  geom_node_point(aes(size = Popularity), color = \"gray\", show.legend = FALSE) +\n  geom_node_text(aes(label = termos[name,]$PrefLabel))\n\n\n\n\n\nVamos usar cores para representar o tipo de conexão e ajustar o tamanho da fonte de acordo com a popularidade:\n\n\nCódigo\nggraph(grafo, layout = \"kk\") + \n  geom_edge_density(aes(fill = edge), show.legend = FALSE) +\n  geom_node_point(aes(colour = Community, size = Popularity), show.legend = FALSE) + \n  geom_edge_parallel(aes(color = edge),\n                 arrow = arrow(length = unit(1, \"mm\")), \n                 start_cap = circle(3, \"mm\"),\n                 end_cap = circle(3, \"mm\")) +\n  geom_node_text(aes(label = termos[name,]$PrefLabel, size = 3 + Popularity),\n                 alpha = 0.75) +\n  theme(legend.title = element_blank(), legend.position = \"bottom\",\n        legend.justification = \"right\", legend.direction = \"horizontal\") + \n  guides(size = \"none\")\n\n\n\n\n\nA visualização acima usa um efeito de densidade para representar as áreas de acordo com relações por PrefLabel ou AltLabel. É possível ver aqui que as PrefLabels (azul) predominam por todo o grafo, à exceção da área ao redor do nó data set.\nVejamos quais são as AltLabels desse termo:\n\n\nCódigo\ntermos %>% \n  filter(PrefLabel %in% c(\"data set\")) %>% \n  select(AltLabel_1, AltLabel_2, AltLabel_3)\n\n\n\n\n  \n\n\n\nNa verdade, a única AltLabel para “data set” é “dataset”. Se observarmos mais de perto, podemos perceber que a maioria das relações para “data set” ocorrem por sua AltLabel e não pelo nome principal:\n\n\nCódigo\ngrafo %>% \n  filter(Community %in% c(1, 2, 5)) %>% \n\n  ggraph(layout = \"kk\") + \n  \n  geom_edge_fan(aes(color = edge, start_cap = label_rect(node1.name),\n    end_cap = label_rect(node2.name)),\n    edge_width = 0.25,\n    arrow = arrow(length = unit(1, \"mm\")), \n    start_cap = circle(4, \"mm\"),\n    end_cap = circle(4, \"mm\")) +\n  \n  geom_node_point(aes(colour = Community, size = Popularity), show.legend = FALSE) + \n  \n  geom_node_text(aes(\n    label = termos[name,]$PrefLabel,\n    size = Popularity,\n    alpha = Popularity),\n    show.legend = FALSE,\n    repel = TRUE) +\n  theme(legend.title = element_blank(), legend.position = \"bottom\",\n        legend.direction = \"horizontal\", legend.justification = \"right\") +\n  facet_edges(~edge)\n\n\n\n\n\nVamos usar o geom geom_node_label no lugar de geom_node_text para ter um fundo branco em nossas labels e usar a propriedade repel = TRUE para evitar tantas sobreposições.\n\n\nCódigo\nggraph(grafo, layout = \"kk\") + \ngeom_edge_parallel(aes(color = edge, start_cap = label_rect(node1.name),\n  end_cap = label_rect(node2.name)),\n  angle_calc = \"along\",\n  label_size = 1,\n  label_dodge = unit(2.5, \"mm\"),\n  arrow = arrow(length = unit(1, \"mm\")), \n  start_cap = circle(4, \"mm\"),\n  end_cap = circle(4, \"mm\")) +\ngeom_node_point(aes(colour = Community, size = Popularity), show.legend = FALSE) + \ngeom_node_label(aes(\n  label = termos[name,]$PrefLabel,\n  size = 3 + Popularity),\n  show.legend = FALSE,\n  repel = TRUE,\n  alpha = 0.75) +\ntheme(legend.title = element_blank(), legend.position = \"bottom\", legend.justification = \"right\", legend.direction = \"horizontal\")\n\n\n\n\n\nO resultado é bem mais legível, mas ainda não é apropriado para uma pequena área de visualização. Nesta página, estamos usando toda a área disponível e mesmo assim a visualização é difícil. O gráfico está poluído e não é possível discernir a que cada label se refere.\nVamos separar um pouco mais, retirando os conjuntos menores.\n\nClusterização\nA visão geral pode ser interessante, mas é mais apropriada para visualizações interativas que possam ser arrastadas e usar de recursos como zoom e a exibição dinâmica dos nomes dos nós — ao tocar ou passar o mouse em cima, por exemplo. Esse processo será abordado na seção 5.\nPara continuar a análise, vamos criar clusters, ou seja, conjuntos menores de nós onde poderemos focar.\nAs bibliotecas que lidam com estruturas de dados como grafos fornecem recursos úteis para manipular e segmentar esses dados, encontrando subgrupos dentro deles e separando suas relações. Um desses recursos é a possibilidade de automaticamente encontrar quais são as “comunidades” de nós, ou seja, quais nós possuem mais proximidade dentro da rede.\nVamos gerar um novo gráfico que exiba numericamente as comunidades nas labels:\n\n\nCódigo\nggraph(grafo, layout = \"kk\") + \n  geom_edge_parallel(aes(color = edge, start_cap = label_rect(node1.name),\n    end_cap = label_rect(node2.name)),\n    angle_calc = \"along\",\n    label_size = 1,\n    label_dodge = unit(2.5, \"mm\"),\n    arrow = arrow(length = unit(1, \"mm\")), \n    start_cap = circle(4, \"mm\"),\n    end_cap = circle(4, \"mm\"),\n    show.legend = FALSE) +\n  geom_node_point(aes(colour = Community, size = Popularity), show.legend = FALSE) + \n  geom_node_label(aes(\n    label = Community),\n    show.legend = FALSE,\n    repel = TRUE,\n    alpha = 0.75)\n\n\n\n\n\nCom base nessa vizualização podemos pensar em novos conjuntos clusterizados:\n\ncluster_data_repository <- grafo %>% \n  filter(Community == 7)\n\nEsse conjunto mostrará apenas o pequeno cluster de cinco nós, nomeado pelo seu nó mais popular, “data repository”:\n\n\nCódigo\nggraph(cluster_data_repository, layout = \"kk\") + \n  \n  geom_edge_parallel(aes(color = edge, start_cap = label_rect(node1.name),\n    end_cap = label_rect(node2.name)),\n    arrow = arrow(length = unit(1, \"mm\")), \n    start_cap = circle(4, \"mm\"),\n    end_cap = circle(4, \"mm\")) +\n  \n  geom_node_point(aes(colour = Community, size = Popularity), show.legend = FALSE) + \n  \n  geom_node_label(aes(\n    label = termos[name,]$PrefLabel),\n    show.legend = FALSE,\n    repel = TRUE,\n    alpha = 0.75) +\n  theme(legend.title = element_blank(), legend.position = c(1,0.05),\n        legend.direction = \"horizontal\", legend.justification = \"right\",\n        legend.background = element_rect(fill = \"transparent\"),\n        legend.box.background = element_rect(fill = \"transparent\", color = \"transparent\")) +\n    facet_graph(~Community)\n\n\n\n\n\nAgora vamos separar nosso cluster principal, onde está a maior parte da amostra:\n\ncluster_principal <- grafo %>% \n  filter(Community %in% c(1:6, 8:10, 14, 15, 22))\n\n\n\nCódigo\nggraph(cluster_principal, layout = \"kk\") + \ngeom_edge_parallel(aes(color = edge, start_cap = label_rect(node1.name),\n  end_cap = label_rect(node2.name)),\n  arrow = arrow(length = unit(1, \"mm\")), \n  start_cap = circle(4, \"mm\"),\n  end_cap = circle(4, \"mm\")) +\ngeom_node_point(aes(colour = Community, size = Popularity), show.legend = FALSE) + \ngeom_node_label(aes(\n  label = termos[name,]$PrefLabel,\n  size = 5 + Popularity),\n  show.legend = FALSE,\n  repel = TRUE,\n  alpha = 0.75) +\ntheme(legend.title = element_blank(), legend.position = \"bottom\",\n      legend.justification = \"right\", legend.direction = \"horizontal\")\n\n\n\n\n\nPara podermos segmentar mais ainda, vamos novamente visualizar as comunidades, dessa vez com o tamanho e a opacidade ajustadas por popularidade:\n\n\nCódigo\nggraph(cluster_principal, layout = \"kk\") + \n  geom_edge_fan(aes(color = edge, start_cap = label_rect(node1.name),\n    end_cap = label_rect(node2.name)),\n    arrow = arrow(length = unit(1, \"mm\")), \n    start_cap = circle(4, \"mm\"),\n    end_cap = circle(4, \"mm\")) +\n  geom_node_point(aes(colour = Community, size = Popularity)) + \n  geom_node_text(aes(label = termos[name,]$PrefLabel, size = Popularity),\n                 color = \"darkgray\", alpha = 1) +\n  geom_node_label(aes(label = Community), repel = TRUE) +\n  theme(legend.position = \"none\")\n\n\n\n\n\n\n\nAnálise da popularidade\nAgora que temos as comunidades bem definidas visualmente, vamos incluir os valores de popularidade no conjunto principal para podermos extrair algumas informações sobre a métrica:\n\ntermos <- termos %>% \n  mutate(Popularity = 0) %>% \n  mutate(id = row_number())\n\nfor (obs in 1:nrow(termos)) {\n  termos[obs,]$Popularity <- sum(relacoes$to == termos[obs,]$id)\n}\n\nrm(obs)\n\ntermos <- termos %>% \n  select(concept_id, Popularity, PrefLabel,\n         Definition, AltLabel_1, AltLabel_2, AltLabel_3)\n\nO conjunto termos agora inclui dados de popularidade. Podemos ver quais são os termos mais populares:\n\ntermos %>% \n  filter(Popularity > 0) %>% \n  arrange(desc(Popularity))\n\n\n\n  \n\n\n\nE podemos ver também quais são os níveis existentes de popularidade:\n\ntable(termos$Popularity)\n\n\n  0   1   2   3   4   5   6   8  10  11  19 \n159  29   8   5   3   1   2   1   1   1   1 \n\n\nA grande maioria dos termos (159) tem popularidade zero. 29 termos recebem apenas uma ligação e 8 recebem duas. Os demais termos, que recebem 3 ou mais ligações, juntos são apenas 15.\nTambém podemos representar isso da seguinte forma:\n\n\nCódigo\ndata.frame(popularidade = c(\"zero\", \"1\", \"2\", \"3 ou mais\"),\n           quantidade = c(159, 29, 8, 15)) %>%\n  ggplot(aes(x = \"\", y = quantidade, fill = popularidade)) +\n  geom_bar(stat = \"identity\", width = 1) +\n  coord_polar(\"y\", start = 0) +\n  labs(title = \"Popularidade dos termos\", subtitle = \"159 termos não recebem ligações.\")\n\n\n\n\n\nPodemos também saber qual é a popularidade média:\n\nmean(termos$Popularity)\n\n[1] 0.6492891\n\n\nOu a popularidade média entre termos com popularidade acima de zero:\n\ntermos %>% \n  filter(Popularity > 0) %>% \n  select(Popularity) %>% \n  summary()\n\n   Popularity    \n Min.   : 1.000  \n 1st Qu.: 1.000  \n Median : 1.000  \n Mean   : 2.635  \n 3rd Qu.: 3.000  \n Max.   :19.000  \n\n\nA popularidade média quando acima de zero é de 2.635.\nCom base nesses dados, abaixo foi desenvolvida uma relação de quais seriam possíveis nomes para cada categoria a partir dos nós mais relevantes em cada comunidade.\nA tabela está ordenada da maior à menor popularidade e limita-se à amostra do cluster principal.\n\n\n\nComunidade\nNó\nPopularidade\n\n\n\n\n2\nmetadata\n19\n\n\n3\nresearch data\n11\n\n\n1\ndata set\n10\n\n\n4\npersonal data\n8\n\n\n5\ndata management\n6\n\n\n2\ndata quality\n6\n\n\n6\nraw data\n5\n\n\n2\ndata interoperability\n4\n\n\n8\ndata protection\n4\n\n\n3\npersistent identifier\n4\n\n\n1\ndata accessibility\n3\n\n\n5\ndata collection\n3\n\n\n9\ndata structure\n3\n\n\n4\ndata subject\n3\n\n\n3\nidentifier\n3\n\n\n10\ndata findability\n2\n\n\n\n\n\nCategorização\nSe você veio até aqui pelo atalho e gostaria de saber o que significam termos como nó e popularidade, pode encontrar uma explicação na seção 1.\nEm nossa amostra principal estão contempladas todas as comunidades de 1 a 10, com exceção da comunidade 7, que não conecta-se ao cluster principal.\nAlém destas 9 comunidades, que são as maiores e mais populares, restam ainda três comunidades menores: 14, 15 e 22.\nVamos começar nossa viagem por elas.\nAbaixo podemos ver as três separadamente:\n\n\nCódigo\ncluster_principal %>%\n  filter(Community %in% c(14, 15, 22)) %>% \n  ggraph(layout = \"kk\") + \n  geom_edge_parallel(aes(color = edge, start_cap = label_rect(node1.name),\n    end_cap = label_rect(node2.name)),\n    arrow = arrow(length = unit(1, \"mm\")), \n    start_cap = circle(4, \"mm\"),\n    end_cap = circle(4, \"mm\")) +\n  geom_node_point(aes(colour = Community, size = Popularity), show.legend = FALSE) + \n  geom_node_text(aes(\n    label = termos[name,]$PrefLabel, size = 4 + Popularity),\n    show.legend = FALSE,\n    repel = TRUE,\n    alpha = 0.70,\n    check_overlap = TRUE) +\n  theme(legend.title = element_blank(), legend.position = \"bottom\",\n        legend.direction = \"horizontal\", legend.justification = \"right\") +\n    facet_graph(~Community)\n\n\n\n\n\nAs comunidades 14 e 22 estão bastante próximas no grafo, tendo como ponte o cluster research data:\n\n\nCódigo\ncluster_principal %>%\n  filter(Community %in% c(14, 22, 3)) %>% \n  ggraph(layout = \"kk\") + \n  geom_edge_parallel(aes(color = edge, start_cap = label_rect(node1.name),\n    end_cap = label_rect(node2.name)),\n    arrow = arrow(length = unit(1, \"mm\")), \n    start_cap = circle(4, \"mm\"),\n    end_cap = circle(4, \"mm\")) +\n  geom_node_point(aes(colour = Community, size = Popularity), show.legend = TRUE) + \n  geom_node_text(aes(\n    label = termos[name,]$PrefLabel, size = 4 + Popularity),\n    show.legend = FALSE,\n    repel = TRUE,\n    alpha = 0.5) +\n  theme(legend.title = element_blank(), legend.position = \"bottom\",\n        legend.direction = \"horizontal\", legend.justification = \"right\")  +\n  guides(size = \"none\")\n\n\n\n\n\nNa visualização acima, podemos ver que a comunidade 14 tem como ponto mais externo “data governance”. Esse termo faz a ponte para os demais de sua comunidade.\nO mesmo acontece com “data archiving”. Se este termo não fosse mencionado por “data lifecycle”, a comunidade seria outra das que ficaram excluídas do cluster principal.\nJá a comunidade 15 está mais próxima da comunidade 2, metadata. Ela aparece abaixo em azul, na parte inferior do gráfico:\n\n\nCódigo\ncluster_principal %>%\n  filter(Community %in% c(14, 22, 15, 2, 3)) %>% \n  ggraph(layout = \"kk\") + \n  geom_edge_parallel(aes(color = edge, start_cap = label_rect(node1.name),\n    end_cap = label_rect(node2.name)),\n    arrow = arrow(length = unit(1, \"mm\")), \n    start_cap = circle(4, \"mm\"),\n    end_cap = circle(4, \"mm\")) +\n  geom_node_point(aes(colour = Community, size = Popularity), show.legend = TRUE) + \n  geom_node_text(aes(\n    label = termos[name,]$PrefLabel, size = 20 + Popularity),\n    show.legend = FALSE,\n    repel = TRUE,\n    alpha = 0.5) +\n  theme(legend.title = element_blank(), legend.position = \"bottom\",\n        legend.direction = \"horizontal\", legend.justification = \"right\")  +\n  guides(size = \"none\")\n\n\n\n\n\nA visualização acima mostra as três comunidades menores, 14, 15 e 22, junto de suas vizinhas maiores, o cluster metadata (número 2, em laranja, abaixo) e o cluster research data (número 3, em verde, acima).\nOutro fato visível nesta visualização é como a comunidade 5 representa um ponto nevrálgico entre quase todas as principais comunidades. Sem ela, a comunidade 3, research data, uma das três maiores, ficaria isolada das duas outras.\nPodemos confirmar isso na visualização abaixo, inclui todas as comunidades do cluster principal exceto a comunidade 5:\n\n\nCódigo\ncluster_principal %>%\n  filter(!Community %in% c(5)) %>% \n  ggraph(layout = \"kk\") + \n  geom_edge_parallel(aes(color = edge, start_cap = label_rect(node1.name),\n    end_cap = label_rect(node2.name)),\n    arrow = arrow(length = unit(1, \"mm\")), \n    start_cap = circle(4, \"mm\"),\n    end_cap = circle(4, \"mm\")) +\n  geom_node_point(aes(colour = Community, size = Popularity), show.legend = TRUE) + \n  geom_node_text(aes(\n    label = termos[name,]$PrefLabel, size = 4 + Popularity),\n    show.legend = FALSE,\n    repel = TRUE,\n    alpha = 0.5) +\n  theme(legend.title = element_blank(), legend.position = \"bottom\",\n        legend.direction = \"horizontal\", legend.justification = \"right\")  +\n  guides(size = \"none\")\n\n\n\n\n\nAqui podemos ver um recorte desse coração do grafo, com as quatro comunidades juntas: 1, 2, 3 e 5.\n\n\nCódigo\ncluster_principal %>%\n  filter(Community %in% c(1, 2, 3, 5)) %>% \n  ggraph(layout = \"kk\") + \n  geom_edge_parallel(aes(color = edge, start_cap = label_rect(node1.name),\n    end_cap = label_rect(node2.name)),\n    arrow = arrow(length = unit(1, \"mm\")), \n    start_cap = circle(4, \"mm\"),\n    end_cap = circle(4, \"mm\")) +\n  geom_node_point(aes(colour = Community, size = Popularity), show.legend = TRUE) + \n  geom_node_label(aes(\n    label = termos[name,]$PrefLabel, size = 4 + Popularity),\n    show.legend = FALSE,\n    repel = TRUE,\n    alpha = 0.7) +\n  theme(legend.title = element_blank(), legend.position = \"bottom\",\n        legend.direction = \"horizontal\", legend.justification = \"right\")  +\n  guides(size = \"none\")\n\n\n\n\n\nE nessa visualização vemos elas junto com as três menores onde começamos nossa viagem:\n\n\nCódigo\ncluster_principal %>%\n  filter(Community %in% c(1, 2, 3, 5, 14, 15, 22)) %>% \n  ggraph(layout = \"kk\") + \n  geom_edge_parallel(aes(color = edge, start_cap = label_rect(node1.name),\n    end_cap = label_rect(node2.name)),\n    arrow = arrow(length = unit(1, \"mm\")), \n    start_cap = circle(4, \"mm\"),\n    end_cap = circle(4, \"mm\")) +\n  geom_node_point(aes(colour = Community, size = Popularity), show.legend = TRUE) + \n  geom_node_label(aes(\n    label = termos[name,]$PrefLabel, size = 4 + Popularity),\n    show.legend = FALSE,\n    repel = TRUE,\n    alpha = 0.7) +\n  theme(legend.title = element_blank(), legend.position = \"bottom\",\n        legend.direction = \"horizontal\", legend.justification = \"right\")  +\n  guides(size = \"none\")\n\n\n\n\n\nDuas comunidades relativamente pequenas, mas com um pouco mais de popularidade, também estão bastante próximas a esse núcleo: 6 e 10.\n\n\nCódigo\ncluster_principal %>%\n  filter(Community %in% c(6, 10)) %>% \n  ggraph(layout = \"kk\") + \n  geom_edge_parallel(aes(color = edge, start_cap = label_rect(node1.name),\n    end_cap = label_rect(node2.name)),\n    arrow = arrow(length = unit(1, \"mm\")), \n    start_cap = circle(4, \"mm\"),\n    end_cap = circle(4, \"mm\")) +\n  geom_node_point(aes(colour = Community, size = Popularity), show.legend = TRUE) + \n  geom_node_label(aes(\n    label = termos[name,]$PrefLabel, size = 4 + Popularity),\n    show.legend = FALSE,\n    repel = TRUE,\n    alpha = 0.7) +\n  theme(legend.title = element_blank(), legend.position = \"bottom\",\n        legend.direction = \"horizontal\", legend.justification = \"right\")  +\n  guides(size = \"none\") +\n  facet_graph(~Community)\n\n\n\n\n\nElas fazem pontes com o cluster metadata:\n\n\nCódigo\ncluster_principal %>%\n  filter(Community %in% c(2, 6, 10)) %>% \n  ggraph(layout = \"kk\") + \n  geom_edge_parallel(aes(color = edge, start_cap = label_rect(node1.name),\n    end_cap = label_rect(node2.name)),\n    arrow = arrow(length = unit(1, \"mm\")), \n    start_cap = circle(4, \"mm\"),\n    end_cap = circle(4, \"mm\")) +\n  geom_node_point(aes(colour = Community, size = Popularity), show.legend = TRUE) + \n  geom_node_text(aes(\n    label = termos[name,]$PrefLabel, size = 4 + Popularity),\n    show.legend = FALSE,\n    repel = TRUE,\n    alpha = 0.5) +\n  theme(legend.title = element_blank(), legend.position = \"bottom\",\n        legend.direction = \"horizontal\", legend.justification = \"right\")  +\n  guides(size = \"none\")\n\n\n\n\n\nJuntando portanto todas as comunidades centrais, com as quatro maiores e suas imediações formadas pelas pequenas comunidades (2, 6, 10, 14, 15, 22) temos um grafo já bastante recheado:\n\n\nCódigo\ncluster_principal %>%\n  filter(Community %in% c(1, 2, 3, 5, 2, 6, 10, 14, 15, 22)) %>% \n  ggraph(layout = \"kk\") + \n  geom_edge_parallel(aes(color = edge, start_cap = label_rect(node1.name),\n    end_cap = label_rect(node2.name)),\n    arrow = arrow(length = unit(1, \"mm\")), \n    start_cap = circle(4, \"mm\"),\n    end_cap = circle(4, \"mm\")) +\n  geom_node_point(aes(colour = Community, size = Popularity), show.legend = TRUE) + \n  geom_node_label(aes(\n    label = termos[name,]$PrefLabel, size = 4 + Popularity),\n    show.legend = FALSE,\n    repel = TRUE,\n    alpha = 0.7) +\n  theme(legend.title = element_blank(), legend.position = \"bottom\",\n        legend.direction = \"horizontal\", legend.justification = \"right\")  +\n  guides(size = \"none\")\n\n\n\n\n\nRestam apenas as comunidades, 4, 8 e 9 que formam as bordas esquerda e direita do cluster principal.\nAs comunidades 4 e 8 são muito próximas, e falam sobre a proteção de dados e o sujeito de dados. Elas possuem relações entre si, independentemente de outros conjuntos.\n\n\nCódigo\ncluster_personal_data <- cluster_principal %>%\n  filter(Community %in% c(4, 8)) %>% \n  ggraph(layout = \"kk\") + \n  geom_edge_parallel(aes(color = edge, start_cap = label_rect(node1.name),\n    end_cap = label_rect(node2.name)),\n    arrow = arrow(length = unit(1, \"mm\")), \n    start_cap = circle(4, \"mm\"),\n    end_cap = circle(4, \"mm\")) +\n  geom_node_point(aes(colour = Community, size = Popularity), show.legend = TRUE) + \n  geom_node_text(aes(\n    label = termos[name,]$PrefLabel, size = 4 + Popularity),\n    show.legend = FALSE,\n    repel = TRUE,\n    alpha = 0.7) +\n  theme(legend.title = element_blank(), legend.position = \"bottom\",\n        legend.direction = \"horizontal\", legend.justification = \"right\")  +\n  guides(size = \"none\") +\n  facet_graph(~Community, margins = TRUE)\n\ncluster_personal_data\n\n\n\n\n\nSua ligação com o cluster principal não é através do cluster metadata, mas sim do nó “data security” (da comunidade 8) que se conecta ao nó “data integrity” do cluster data set:\n\n\nCódigo\ncluster_principal %>%\n  filter(Community %in% c(1, 4, 8)) %>% \n  ggraph(layout = \"kk\") + \n  geom_edge_parallel(aes(color = edge, start_cap = label_rect(node1.name),\n    end_cap = label_rect(node2.name)),\n    arrow = arrow(length = unit(1, \"mm\")), \n    start_cap = circle(4, \"mm\"),\n    end_cap = circle(4, \"mm\")) +\n  geom_node_point(aes(colour = Community, size = Popularity), show.legend = TRUE) + \n  geom_node_text(aes(\n    label = termos[name,]$PrefLabel, size = 4 + Popularity),\n    show.legend = FALSE,\n    repel = TRUE,\n    alpha = 0.5) +\n  theme(legend.title = element_blank(), legend.position = \"bottom\",\n        legend.direction = \"horizontal\", legend.justification = \"right\")  +\n  guides(size = \"none\")\n\n\n\n\n\nEste é um de meus recortes preferidos. Ele mostra um caminho significativo que vai de “dados pessoais” para “proteção de dados” e que então faz uma ponte que passa por “segurança” e “integridade de dados” para só então desaguar no conjunto principal.\nPor fim, no outro extremo do grafo, no lado esquerdo, temos a pequena comunidade 9, que orbita ao redor do nó “data structure”:\n\n\nCódigo\ncluster_principal %>%\n  filter(Community %in% c(9)) %>% \n  ggraph(layout = \"kk\") + \n  geom_edge_parallel(aes(color = edge, start_cap = label_rect(node1.name),\n    end_cap = label_rect(node2.name)),\n    arrow = arrow(length = unit(1, \"mm\")), \n    start_cap = circle(4, \"mm\"),\n    end_cap = circle(4, \"mm\")) +\n  geom_node_point(aes(colour = Community, size = Popularity), show.legend = TRUE) + \n  geom_node_label(aes(\n    label = termos[name,]$PrefLabel, size = 4 + Popularity),\n    show.legend = FALSE,\n    repel = TRUE,\n    alpha = 0.7) +\n  theme(legend.title = element_blank(), legend.position = \"none\",\n        legend.direction = \"horizontal\", legend.justification = \"right\")  +\n  guides(size = \"none\") +\n  facet_graph(~Community)\n\n\n\n\n\nAtravés de “PID record” ela conecta-se a “persistent identifier”, que por sua vez está ligado ao cluster research data:\n\n\nCódigo\ncluster_principal %>%\n  filter(Community %in% c(3, 9)) %>% \n  ggraph(layout = \"kk\") + \n  geom_edge_parallel(aes(color = edge, start_cap = label_rect(node1.name),\n    end_cap = label_rect(node2.name)),\n    arrow = arrow(length = unit(1, \"mm\")), \n    start_cap = circle(4, \"mm\"),\n    end_cap = circle(4, \"mm\")) +\n  geom_node_point(aes(colour = Community, size = Popularity), show.legend = TRUE) + \n  geom_node_text(aes(\n    label = termos[name,]$PrefLabel, size = 4 + Popularity),\n    show.legend = FALSE,\n    repel = TRUE,\n    alpha = 0.5) +\n  theme(legend.title = element_blank(), legend.position = \"bottom\",\n        legend.direction = \"horizontal\", legend.justification = \"right\")  +\n  guides(size = \"none\")\n\n\n\n\n\nAqui voltamos a nossa primeira visualização geral do cluster principal, com todas as suas comunidades:\n\n\nCódigo\nggraph(cluster_principal, layout = \"kk\") + \ngeom_edge_parallel(aes(color = edge, start_cap = label_rect(node1.name),\n  end_cap = label_rect(node2.name)),\n  arrow = arrow(length = unit(1, \"mm\")), \n  start_cap = circle(4, \"mm\"),\n  end_cap = circle(4, \"mm\")) +\ngeom_node_point(aes(colour = Community, size = Popularity), show.legend = FALSE) + \ngeom_node_label(aes(\n  label = termos[name,]$PrefLabel,\n  size = 5 + Popularity),\n  show.legend = FALSE,\n  repel = TRUE,\n  alpha = 0.75) +\ntheme(legend.title = element_blank(), legend.position = \"bottom\",\n      legend.justification = \"right\", legend.direction = \"horizontal\")\n\n\n\n\n\n\n\nOutros protótipos\nPara registro da exploração, seguem abaixo alguns outros protótipos que usam diferentes layouts:\n\n\nCódigo\ncluster_principal %>% \n  ggraph(layout = \"partition\", circular = TRUE) +\n  geom_edge_diagonal() + \n  geom_node_point(aes(size = Popularity, color = Community), show.legend = FALSE) + \n  geom_node_text(aes(label = name), color = \"black\", check_overlap = TRUE, size = 4) +\n  coord_fixed()\n\n\n\n\n\n\n\nCódigo\ngrafo %>% \n  filter(Community %in% c(1:2)) %>% \n  ggraph(layout = \"linear\") + \n    geom_edge_arc(aes(), color = \"gray\") +\n    geom_node_point(aes(size = Popularity, color = Popularity), show.legend = FALSE) +\n    geom_node_text(aes(label = termos[name,]$PrefLabel), nudge_y = -3, size = 4) +\n    facet_graph(~ Community) +\n    coord_flip()\n\n\n\n\n\n\n\nCódigo\ngrafo %>% \n  filter(Community %in% c(9:12)) %>% \n  ggraph(layout = \"linear\", circular = TRUE) + \n  geom_edge_arc(aes(color = edge)) + \n  geom_node_point(aes(size = Popularity, color = Community), show.legend = TRUE) +\n  geom_node_text(aes(label = termos[name,]$PrefLabel), size = 5, nudge_y = -0.15, angle = -0) +\n  theme(legend.position = \"bottom\", legend.direction = \"horizontal\") +\n  guides(size = \"none\")\n\n\n\n\n\n\n\nCódigo\ngrafo %>% \n  filter(Community %in% c(7,5,12)) %>% \n  ggraph(\"tree\") + \n  geom_edge_diagonal(aes(color = edge)) +\n  geom_node_label(aes(label = termos[name,]$PrefLabel, fill = Community),\n                 color = \"white\",\n                 fontface = \"bold\",\n                 size = 2.5,\n                 nudge_x = 0,\n                 nudge_y = -0.130,\n                 label.padding = unit(0.25, \"lines\")) +\n  theme(legend.position = \"bottom\", legend.justification = \"left\", legend.direction = \"horizontal\", legend.background = element_rect(fill = \"transparent\"), legend.box.background = element_rect(fill = \"transparent\", color = \"transparent\")) +\n  coord_flip()\n\n\n\n\n\nDemais referências da pesquisa:\n\nNetwork with node size based on edge number – the R Graph Gallery\nClustering result visualization with network diagram – the R Graph Gallery\nNetwork Analysis with R | Manipulating Network Data\nA Rogue Historian - Introduction to Network Analysis with R\nNetwork Visualization Essentials in R - Articles - STHDA\nInteractive Network Visualization with R | R-bloggers"
  },
  {
    "objectID": "mdst_graphs.html#compartilhar",
    "href": "mdst_graphs.html#compartilhar",
    "title": "Grafos e relações semânticas na linguagem natural",
    "section": "5. Compartilhar",
    "text": "5. Compartilhar\nOs dados aqui contam a história de uma viagem por diferentes campos semânticos. Temos termos que pertencem a um mesmo contexto, a gestão de dados, mas que têm diferentes níveis de proximidade.\nNo começo, parti com o objetivo de determinar quais termos tinham mais relevância. Ficou bastante evidente que termos como metadados e data set são bastante importantes para podermos compreender inúmeros outros, ou seja, eles são componentes importantes para explicar e precisar o vocabulário de dados.\nOutro termo de grande destaque também foi personal data, que aparece com importância para explicar ideias relacionadas à proteção de dados. Esse termo gerou uma das relações entre comunidades mais semanticamente significativas.\n\n\n\n\n\nVisualizações como essa podem exemplificar o poder de pensar os termos não só por suas repetições mas especialmente por suas relações e como essas relações os agrupam. É justamente o nó “segurança de dados” que faz a ponte externa desse conjunto para o cluster principal.\nApesar de não terem grande popularidade, esses termos que realizam pontes, mencionando ou sendo mencionados por outros termos fora de suas comunidades, também poderiam ser pensados como tendo importância específica na análise de relações em linguagem natural, já que sem eles teríamos uma rede semântica mais dispersa.\nAo pensar em análise de definições, a menção de um termo implica não somente conexão ou relevância mas uma possível necessidade daquela palavra para conseguir definir outro termo.\nNumericamente, esses foram os resultados finais da métrica de popularidade:\n\n\nCódigo\ntermos %>% \n  filter(Popularity > 0) %>% \n  arrange(desc(Popularity)) %>% \n  select(PrefLabel, Popularity) %>% \n  rename(Termo = PrefLabel) %>% \n  rename(Popularidade = Popularity)\n\n\n\n\n  \n\n\n\nPara pessoas que se interessam ou trabalham com o processamento de linguagem natural, ou que precisam determinar a importância de diferentes conceitos para estudar ou ensinar sobre eles, o mapeamento de relações semânticas pode ser uma ferramenta bastante didática.\nComo última etapa, gostaria ainda de explorar a possibilidade de navegar interativamente por este grafo após ter mergulhado e nadado nele por algum tempo. Essa intenção surgiu após as primeiras plotagens, pois durante todo o processo muitos gráficos acabam poluídos demais pelo texto que identifica cada ponto.\nBibliotecas para visualização interativa de grafos permitem que o texto identificador apareça apenas quando interagimos com um determinado nó.\n\nnetworkD3\n\nlibrary(networkD3)\n\n\nModelagem\nCria uma estrutura para edges conforme requisitado pela biblioteca:\n\nedges_d3 <- relacoes %>% \n  rename(Source = from) %>% \n  rename(Target = to) %>% \n  select(-edge)\n\nConverte os valores para inteiros:\n\nedges_d3 <- edges_d3 %>% \n  mutate(across(c(1, 2), as.integer))\n\nCria a estrutura para os nós:\n\nnodes_d3 <- termos %>% \n  mutate(id = row_number()) %>% \n  mutate(popularity = 0) %>% \n  select(id, PrefLabel, popularity, Definition)\n\nÉ necessário ainda diminuir todos os IDs em 1 pois a biblioteca é baseada em um framework JavaScript que usa indexação a partir de 0, ao contrário da linguagem R.\n\nnodes_d3[, 1] <- nodes_d3[, 1] - 1\nedges_d3[, 1:2] <- edges_d3[, 1:2] - 1\n\nAqui a popularidade é calculada e acrescentada ao dataframe de nós e multiplicada por 10 para que a diferença de tamanho seja mais visível:\n\nfor (row in 1:nrow(nodes_d3)) {\n  nodes_d3[row,]$popularity <- 10 * sum(edges_d3$Target == nodes_d3[row,]$id)\n}\n\nrm(row)\n\nPor fim temos uma primeira plotagem interativa:\n\n\nCódigo\nclickScript <- 'console.log(\"click: \" + d.name + \", row \" + (d.index + 1));'\n\nforceNetwork(Links = edges_d3, Nodes = nodes_d3,\n                 NodeID = \"PrefLabel\",\n                 Group = \"popularity\",\n                 zoom = TRUE,\n                 Nodesize = \"popularity\",\n                 opacity = 1,\n                 clickAction = clickScript)\n\n\n\n\n\n\nNa renderização acima é possível dar zoom e arrastar a visualização. Os nomes são exibidos ao tocar ou clicar sobre um nó e é possível ainda movimentá-los.\n\n\n\n\n  \n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\n\n\n\nvisNetwork\nA última biblioteca oferece a possibilidade de exibir as definições completas ao interagir com cada nó.\n\nlibrary(visNetwork)\n\nPara trabalhar com essa biblioteca são necessaŕios também dois dataframes distintos, um para nodes e outro para edges. O dataframe com nodes deve ter uma coluna com IDs e o de edges deve ter colunas from e to que ligam os IDs.\nOutro fator é que as colunas desse dataframe podem ser usadas para passar suas propriedades estéticas.\nVamos fazer essas adaptações:\n\nnodes_vN <- termos %>% \n  mutate(id = row_number()) %>% \n  mutate(size = 0) %>%\n  rename(label = PrefLabel) %>%\n  rename(title = Definition) %>% \n  select(id, label, size, concept_id, title)\n\nfor (row in 1:nrow(nodes_vN)) {\n  nodes_vN[row,]$size <- 2 * (5 + sum(relacoes$to == nodes_vN[row,]$id))\n  if (nodes_vN[row,]$size == 0) {\n    nodes_vN[row,]$size <- 3\n  }\n}\n\nrm(row)\n\nnodes_vN\n\n\n\n  \n\n\n\nCriação do dataframe de edges:\n\nedges_vN <- relacoes %>% \n  mutate(dashes = FALSE) %>% \n  mutate(color = \"red\")\n\nfor (row in 1:nrow(edges_vN)) {\n  if (edges_vN[row,]$edge == \"PrefLabel\") {\n    edges_vN[row,]$color <- \"#CD6839\"\n    edges_vN[row,]$dashes <- FALSE\n  }\n  else {\n    edges_vN[row,]$color <- \"#8B4726\"\n    edges_vN[row,]$dashes <- TRUE\n  }\n}\n\nrm(row); edges_vN\n\n\n\n  \n\n\n\nEsta é a plotagem mais básica, sem argumentos extras:\n\n\nCódigo\nvisNetwork(nodes_vN, edges_vN)\n\n\n\n\n\n\n\nDesde o primeiro gráfico é possível ver que o resultado padrão é muito mais legível do que nas demais bibliotecas.\nUsando mais argumentos podemos personalizar cores e incluir mais controles interativos:\n\n\nCódigo\nvisNetwork(nodes_vN, edges_vN, width = \"100%\") %>% \n  visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE, collapse = TRUE) %>%\n  visNodes(color = list(background = \"#EEE5DE\", border = \"#8B8682\",\n                        highlight = \"#FFA54F\"),\n           shadow = list(enabled = TRUE, size = 10)) %>% \n  visEdges(shadow = TRUE, smooth = TRUE) %>% \n  visLayout(randomSeed = 1) %>% \n  visPhysics(stabilization = FALSE,\n             solver = \"repulsion\") %>% \n  visEvents(selectNode = \"function(properties) {\n      console.log('seleção: ' + this.body.data.nodes.get(properties.nodes[0]).id);}\") %>% \n  visClusteringOutliers()\n\n\n\n\n\n\n\nNa visualização acima é possível dar zoom, arrastar a visão, movimentar e colapsar nós. Quando um nó é selecionada, suas relações são destacadas.\nAbaixo, os mesmos dados com um layout circular.\n\n\nCódigo\nvisNetwork(nodes_vN, edges_vN) %>% \n  visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE, collapse = TRUE,\n             manipulation = TRUE) %>%\n  visNodes(color = list(background = \"#EEE5DE\", border = \"#8B8682\",\n                        highlight = \"#FFA54F\"),\n           shadow = list(enabled = TRUE, size = 10)) %>% \n  visEdges(shadow = TRUE, smooth = TRUE) %>% \n  visIgraphLayout(layout = \"layout_in_circle\") \n\n\n\n\n\n\n\nEste formato é de difíci visualização com tantos nós inclusos. Aqui também está demonstrada a possibilidade de editar os nós com os controles interativos providos pela biblioteca.\n\n\nOutras bibliotecas de visualização de grafos\n\nDiagrammeR"
  },
  {
    "objectID": "mdst_graphs.html#agir",
    "href": "mdst_graphs.html#agir",
    "title": "Grafos e relações semânticas na linguagem natural",
    "section": "6. Agir",
    "text": "6. Agir\nPara pessoas interessadas na gestão de dados, a análise dessa amostra sugere que termos como metadados, interoperabilidade de dados e proteção de dados e são especialmente relevantes para definir outros termos.\nOs grupos de termos de maior destaque entre os termos mais populares são dados pessoais, dados de pesquisa e qualidade de dados.\nOutros termos altamente populares não foram destacados neste último resumo acionável por terem um papel mais passivo como objetos da gestão de dados: conjunto de dados, dados brutos.\nApesar de estar disponível em diferentes idiomas, o português não era uma das contempladas pelo Multilingual Data Stewardship Terminology. Seria possível, porém, cruzar dados de fontes compatíveis que possibilitassem um novo estudo de relações observando variações entre os idiomas."
  },
  {
    "objectID": "mdst_graphs.html#saiba-mais",
    "href": "mdst_graphs.html#saiba-mais",
    "title": "Grafos e relações semânticas na linguagem natural",
    "section": "Saiba mais",
    "text": "Saiba mais\nSe desejar consultar o código fonte você pode encontrá-lo no GitHub.\n\nOutros links\n\nSSHOC Multilingual Data Stewardship Terminology\nPLN para Iniciantes – Insight Data Science Lab\nA Rede Semântica (i) – Humanidades Digitais"
  }
]